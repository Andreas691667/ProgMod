-- class RobotArmEnvironment

-- types public Event = <SensorFail> | <MotorFail> | <RepositionArm>  
                    

-- instance variables
--     private env_pos : real;                 -- current angle (radians)
--     private env_vel : real;                 -- velocity
--     private final_sim_time : real;       -- Assign this in constructor. 
--     private last_time : real;               -- latest time value
--     private io : IO := new IO();
--     private env_acc : real;                 -- acceleration
--     private env_tau : real;
--     private tau_gravity : real := 0;        -- torque gravity [N*m] (assumed to be zero)
--     private tau_friction : real := 0;       -- torque friction [N*m] (assumed to be zero)
--     public events : seq of (real * Event * real) := [];

-- values
--     private N1 : real = 0;                  -- lower bound //operation range
--     private N2 : real = 3.14/2;             -- upper bound //operation range

--     private M1 : real = -10 * 3.14 / 180;   -- lower safety bound (-10 degrees)
--     private M2 : real = (5*3.14)/9;         -- upper bound (100 degrees) //safety limit
--     private m : real = 1.2;                 -- robot arm mass [kg]
--     private r : real = 0.8;                 -- robot arm length [m]
--     private I : real = m*r*r;               -- mass inertia [kg*m^2]   
--     private g : real = -9.82;               -- gravity constant [m/s^2]

--     private Fc : real = 0.1;                -- coloumb friction constant
--     private Fv : real = 0.05;               -- viscous friction constant

-- operations
--     public RobotArmEnvironment: () ==> RobotArmEnvironment
--     RobotArmEnvironment() == (
--         -- initialize variables
--         env_pos := 0;
--         env_vel := 0;
--         env_acc := 0;
--         env_tau := 0;
--         last_time := 0;
--         final_sim_time := 0;
--     );


--     public AddEvent : real * Event * real ==> ()
--     AddEvent(t, e, d) == duration(0) (
--         events := events ^ [mk_(t,e,d)];
--     );

--     public CreateEvent : () ==> ()
--     CreateEvent() == duration(0) (
--         if len events > 0 then (
--             let mk_(event_time, event, event_data) = hd events
--             in if event_time <= time then (
--                 if(event = <MotorFail>)             then MySystem`motor.MotorFailed()
--                 else if(event = <SensorFail>)       then MySystem`sensor.SensorFailed()
--                 else if(event = <RepositionArm>)    then env_pos := event_data;
--             events := tl events;   
--             )
--         );
--         PrintState(time); 
--     );

--     public SetTorque : real ==> ()
--     SetTorque(tau) == duration(0) (
--         env_tau := tau;
--     );


--     private static
--     sinh:real ==> real
--     sinh(v) == (
--         dcl ret : real := (MATH`exp(v) - MATH`exp(-v))/2;
--         return ret;
--     );
--     private static
--     cosh:real ==> real
--     cosh(v) == (
--         dcl ret : real := (MATH`exp(v) + MATH`exp(-v))/2;
--         return ret;
--     );

--     private static
--     tanh:real ==> real
--     tanh(v) == (
--         dcl ret : real := sinh(v)/cosh(v);
--         return ret;
--     );


--     public AdjustArmPosition : () ==> ()
--     AdjustArmPosition() == duration(0) (
--         -- q = q(t-1)*q'(t)*dt
--         dcl dt : real := time/1e9 - last_time;

--         tau_gravity := m * g * r * MATH`cos(env_pos);
--         tau_friction := Fc * tanh(env_vel) + Fv * env_vel;

--         env_acc := (env_tau + tau_gravity - tau_friction) / I;
        
--         -- For now we do this as we have assumed friction to be zero and as such
--         -- the arm will never stop in the case of a failure 
--         -- (we can only set torque to 0 and friction/gravity are assumd to be 0 for now).
--         if(env_tau = 0) then env_vel := 0
--         else env_vel := env_vel + env_acc * dt;

--         env_pos := env_pos + env_vel * dt;  
--         last_time := time/1e9;          
--     );
    

--     -- public Step : () ==> ()
--     -- Step() == duration(0) (
--     --     dcl t : real := time/1e9;
--     --     dcl timeStep : real := t - last_time;
--     --     Step(timeStep);
--     --     last_time := t;
--     -- );

--     -- -- step function private. Cannot access time in a pre-condition so we must pass it as a parameter. 
--     -- private Step : (real) ==> ()
--     -- Step(TimeStep) == duration(0) (      
--     --     env_pos := env_pos + env_vel * TimeStep;
--     --     PrintState(time);
--     -- )

--     -- pre TimeStep > 0 and                                                                    -- positive time 
--     --     (MySystem`ctl.GetTarget()  >= N1 and MySystem`ctl.GetTarget() <= N2) and            -- target angle within operation range
--     --     (MySystem`ctl.GetPosition() <= M2 and MySystem`ctl.GetPosition() >= M1) and         -- current angle within safety range
--     --     (MySystem`ctl.GetVelocity() = 0 or 
--     --     (TimeStep < (M2-MySystem`ctl.GetPosition())/abs(MySystem`ctl.GetVelocity()) and     -- Refer to assignment 2 for derivation
--     --     TimeStep  > (M1-MySystem`ctl.GetPosition())/abs(MySystem`ctl.GetVelocity())))       -- These gives upper bounds for the size of time step.         

--     -- post (MySystem`ctl.GetPosition() <= M2) and (MySystem`ctl.GetPosition() >= M1);
    
--     private PrintState : (real) ==> ()
--     PrintState(time_) == duration(0) (
--         -- dcl str : seq of char := "ENV: \n";
--         dcl str : seq of char := "";
--         --  "env: \n time, env_pos, env_vel, ,\n";
--         str := str ^ VDMUtil`val2seq_of_char[real](time_/1e9); -- print time
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](env_pos); -- print position
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](env_tau); -- print torque
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](env_acc);
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](env_vel); -- print velocity
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](tau_gravity); 
--         str := str ^ ",";
--         str := str ^ VDMUtil`val2seq_of_char[real](tau_friction); 
--         str := str ^ "\n";
--         def - = io.echo(str) in skip;
--     );

--     public GetPosition : () ==> real
--     GetPosition() == duration(0) (    
--         return env_pos;
--     );
    

--     -- Probably better to set this in the constructor so it does not change during simulation. 
--     public SetFinalSimTime : real ==> ()
--     SetFinalSimTime(t) == (
--         final_sim_time := t;
--     );

--     public IsFinished : () ==> ()
--     IsFinished() == (
--         skip
--     );
    

--     sync 
--         per IsFinished => (time > final_sim_time);
--         mutex(CreateEvent);

--     thread
--         periodic(1e8, 0, 0, 0)(CreateEvent);


-- end RobotArmEnvironment